<cfcomponent extends="colddoc.strategy.AbstractTemplateStrategy" output="false" hint="
ColdDuck - JSDuck Document Strategy for ColdDoc

1. Add a folder to ColdDoc/strategy called coldduck
2. Add this component to that folder
3. Read the documentation here:
">

<!------------------------------------------- PUBLIC ------------------------------------------->

<cfscript>
	instance.static.TEMPLATE_PATH = "/colddoc/strategy/api/resources/templates";
</cfscript>


<cffunction name="init" hint="Constructor" access="public" returntype="ColdDuckStrategy" output="false">
	<cfargument name="outputDir" hint="the output directory" type="string" required="Yes">
	<cfargument name="projectTitle" hint="the title of the project" type="string" required="No" default="Untitled">
	<cfscript>
		super.init();

		setOutputDir(arguments.outputDir);
		setProjectTitle(arguments.projectTitle);

		return this;
	</cfscript>
</cffunction>

<cffunction name="run" hint="Run this strategy" access="public" returntype="void" output="false">
	<cfargument name="qMetadata" hint="the meta data query" type="query" required="Yes">
	<cfscript>
		//var basePath = getDirectoryFromPath(getMetaData(this).path);
		//var args = 0;

		//recursiveCopy(basePath & "resources/static", getOutputDir());

		//write the index template
		//args = {path=getOutputDir() & "/index.html", template="#instance.static.TEMPLATE_PATH#/index.html", projectTitle=getProjectTitle()};
		//writeTemplate(argumentCollection=args);

		//writeOverviewSummaryAndFrame(arguments.qMetaData);

		//writeAllClassesFrame(arguments.qMetaData);

		writePackagePages(arguments.qMetaData);
    </cfscript>
</cffunction>

<!------------------------------------------- PACKAGE ------------------------------------------->

<!------------------------------------------- PRIVATE ------------------------------------------->


<cffunction name="writePackagePages" hint="writes the package summaries" access="private" returntype="void" output="true">
	<cfargument name="qMetadata" hint="the meta data query" type="query" required="Yes">
	<cfscript>
		var currentDir = 0;
		var qPackage = 0;
		var qClasses = 0;
		var qInterfaces = 0;
		//writeDump(arguments.qMetaData); abort;
	</cfscript>

<!--- 	<cfquery name="local.sortedMetaDataQry" dbtype="query">
		SELECT * FROM arguments.qMetaData ORDER BY Package
	</cfquery> 
	<cfdump var="#local.sortedMetaDataQry#">--->
	<cfoutput query="arguments.qMetaData" group="package">
	<!--- <cfoutput query="local.sortedMetaDataQry" group="package"> --->
		<cfscript>
			//currentDir = getOutputDir() & "/" & replace(package, ".", "/", "all");
			//ensureDirectory(currentDir);
			writeOutput("<br>package = '#package#'");
			qPackage = getMetaSubquery(arguments.qMetaData, "package = '#package#'", "name asc");
			//writeDump(qPackage);


/*			qClasses = getMetaSubquery(qPackage, "type='component'", "name asc");
			//qInterfaces = getMetaSubquery(qPackage, "type='interface'", "name asc");


			writeTemplate(path=currentDir & "/package-summary.html",
						template="#instance.static.TEMPLATE_PATH#/package-summary.html",
						projectTitle = getProjectTitle(),
						package = package,
						qClasses = qClasses,
						qInterfaces = qInterfaces);

			writeTemplate(path=currentDir & "/package-frame.html",
						template="#instance.static.TEMPLATE_PATH#/package-frame.html",
						projectTitle = getProjectTitle(),
						package = package,
						qClasses = qClasses,
						qInterfaces = qInterfaces);
*/
/*	*/
			//buildClassPages(qPackage,arguments.qMetadata);
			buildClassPages(qPackage);
						
		</cfscript>
	</cfoutput>
	<cfabort>
</cffunction>

<cffunction name="buildClassPages" hint="Builds the class pages for the CFCs contained in the package" access="private" returntype="void" output="true">
	<cfargument name="qPackage" hint="the query for a specific package" type="query" required="Yes">
<!--- 	<cfargument name="qMetadata" hint="the meta data query" type="query" required="Yes"> --->
	<cfscript>
		var qSubClass = 0;
		var qImplementing = 0;
		var currentDir = 0;
		var subClass = 0;
		var safeMeta = 0;
	</cfscript>

	<!--- <cfdump var="#arguments#" ><cfabort> --->

	<cfloop query="arguments.qPackage">
		<cfscript>
							// arguments.qPackage contains a query of all the CFCs 
							// that were found in the same package/folder
			//currentDir = getOutputDir() & "/" & replace(package, ".", "/", "all");
				// The requested output path. I changed this to NOT use the package name
				// since it seemed to be unnecessary. Maybe it is?				
			currentDir = getOutputDir();
			ensureDirectory(currentDir);
			//writeOutput(currentDir); abort;
			
			safeMeta = structCopy(metadata);
writeOutput("<br>safeMetaName="&safeMeta.name);
//writeDump(safeMeta);
/*
			if(safeMeta.type eq "component")
			{
				qSubClass = getMetaSubquery(arguments.qMetaData, "UPPER(extends) = UPPER('#arguments.qPackage.package#.#arguments.qPackage.name#')", "package asc, name asc");
				qImplementing = QueryNew("");
			}
			else
			{
				//all implementing subclasses
				qSubClass = getMetaSubquery(arguments.qMetaData, "UPPER(fullextends) LIKE UPPER('%:#arguments.qPackage.package#.#arguments.qPackage.name#:%')", "package asc, name asc");
				qImplementing = getMetaSubquery(arguments.qMetaData, "UPPER(implements) LIKE UPPER('%:#arguments.qPackage.package#.#arguments.qPackage.name#:%')", "package asc, name asc");
			}
			//writedump(qSubClass); abort;
*/			
			//writeOutput(currentDir & "/#name#.js"); abort;
			writePseudoJSFile(path=currentDir & "/#name#.js", metadata = safeMeta, package=package);
					
		</cfscript>
	</cfloop>

</cffunction>

<cffunction name="writePseudoJSFile" hint="Writes a pseudo JS file for a given CFC" access="private" returntype="void" output="true">
	<cfargument name="path" hint="where to write the template" type="string" required="Yes">
	<cfargument name="metaData" hint="The class metadata" type="struct" required="Yes">
	<cfargument name="package" hint="The package name" type="string" required="Yes">
<!--- 	<cfargument name="name" hint="The cfc/class name" type="string" required="Yes"> --->
	<cfscript>
		var js = "";
		var local = {}; //for local variables
		var NL = "#chr(13)&chr(10)#";
		var stopAtEnd = false;
		/* 
		if (arguments.metaData.name contains 'comments') {
			writeDump(arguments);
			stopAtEnd = true;
		}
		*/
						// Get the metadata for the CFC file
		local.cfcMetadata = arguments.metaData;

		
						// Now add any Properties. eg For a persistant (ORM) class.
						// Hmmmm What if the user has set persistant = false
						// Should we ignore the CFC altogether?
		local.isPersistent = (structKeyExists(cfcMetadata,'PERSISTENT'));	
				
						// Start creating the pseudo js file for this component / class 
						// by adding any Hint text from the cfcomponent tag
		js = "/**";
		
		local.hint = NL & "Sorry, no hint was provided." & NL;	
		
		if (structKeyExists(cfcMetadata,'hint')) hint = cfcMetadata.hint;
		
		if (structKeyExists(cfcMetadata,'TABLE') && isPersistent) {
			js = js & NL & 'I PERSIST to the "#cfcMetadata.TABLE#" table.' &NL; 
		}
		
		js = js & hint & "*/" &NL; 
		
						// Now create the class name details as a JS class
						// TODO: At present ColdDoc wont reach here if there is non DisplayName on the CFC component tag
						// In future, before we get here, if there is no DisplayName, use the CFC filename as CF does.
		local.pathStr = getPackageAndName(arguments.package,cfcMetadata.NAME);
		js = js & "Ext.define('#pathStr#',{" &NL;
		
						// Add Extend if required
		if (structKeyExists(cfcMetadata,'EXTENDS')){			
			if (structKeyExists(cfcMetadata.EXTENDS,'FULLNAME')){
				local.pathStr = getPackageAndName(arguments.package,cfcMetadata.EXTENDS.FULLNAME);
				js= js & 'extend: "#pathStr#",' & NL;	
			}	
		}

						// Get the CFC's PROPERTIES array (if it exists) and process the properties						
		if (structKeyExists(cfcMetadata,'PROPERTIES')){
			js = js & getPropertiesSection(cfcMetadata.Properties);		 			
		}
		
						// Now add the methods / functions for this CFC / class.															
						// Get the CFC's FUNCTIONS array and process it					
		if (structKeyExists(cfcMetadata,'FUNCTIONS')){
			js = js & getFunctionsSection(cfcMetadata.Functions, isPersistent);
		} 
		
						// Write the end of the CFC / JS Class
		js = js & NL & "});" & NL;	
		
		if (stopAtEnd) {
			writeoutput("<pre>#js#</pre>");		
			abort;		
		}

		fileWrite(arguments.path, js);
	</cfscript>
</cffunction>

<cffunction name="getFunctionsSection" hint="" access="private" returntype="string" output="true">
	<cfargument name="cfcFuncs" hint="The metadata functions array" type="array" required="Yes">
	<cfargument name="isPersistent" hint="Whether or not this CFC is persistent" type="boolean" required="Yes">
	<cfscript>
		var local = {};
		var cfcFunctions = arguments.cfcFuncs;
		var NL = "#chr(13)&chr(10)#";
		var js = '';	
		
		for (local.i=1; i lte arrayLen(cfcFunctions); i=i+1) {

						// Start the JSDuck block for this function / method
			js = js & NL & "/**";
			
						// Get the method / function hint content, if it exists
			local.hint = NL;
			if (structKeyExists(cfcFunctions[i],'hint')){
				hint = cfcFunctions[i].hint;
			} else {
				if (not arguments.isPersistent) hint = NL & "Sorry, no hint was provided." & NL;	
			}
						// Add the function Hint text
			js = js & hint;

						
						// Public/Private method
			if (structKeyExists(cfcFunctions[i],'access')){
										// Maybe only for private and public? What about 'remote' etc
				if (cfcFunctions[i].access eq "private") {
					js = js & NL & "@" & cfcFunctions[i].access & NL; 
				}
			}
						
						// Get the function parameters and create the JSDuck notation
			local.parameters = cfcFunctions[i].parameters;
			local.parmList = '';
			local.methodAnnotation = '';
			
						// Loop over the function parameters, adding relevant JSDuck annotation
			for (local.p=1; p lte arrayLen(parameters); p=p+1) {			

				local.paramAnnotation = '';

						// Data type
				local.pType = "Any";
				if (structKeyExists(parameters[p],'type')) pType = parameters[p].type;
				
				hint = "";
				if (not arguments.isPersistent) hint = "No hint";
				if (structKeyExists(parameters[p],'hint')) hint = parameters[p].hint;
				
						// Process the parameter name
						// Look at whether it is required or not and any default values
				local.paramNameStr = parameters[p].name;
				local.paramNameAnnotateStr = paramNameStr & " Required";
				
				if (structKeyExists(parameters[p],'required')) {
					if (not parameters[p].required) {
									// Not required. Therefore there should be a 'default' attribute
						local.defValue = 'Any';
						if (structKeyExists(parameters[p],'default')) {
							if (parameters[p]['default'] neq '') {
								defValue = parameters[p]['default'];
							} else {
								defValue = "''";
							}
							
						}
						paramNameAnnotateStr = '[#parameters[p].name#=#defValue#]';
					}
				}
				
								
						// Save the parameter name to a list to use below in the JS function() line
				parmList = ListAppend(parmList,paramNameStr);				
						
				paramAnnotation = paramAnnotation & "@param {#pType#} #paramNameAnnotateStr# #hint#" & NL;
				
				methodAnnotation = methodAnnotation & paramAnnotation;		
			} // End loop function parameters
			
									// Add the return type
			local.returnType = "Any";	
			if (structKeyExists(cfcFunctions[i],'returntype')) local.returnType = cfcFunctions[i].returntype;	
			methodAnnotation = methodAnnotation & "@return {#local.returnType#}" &NL;

									// End of Class JSDuck annotation text
			js = js & methodAnnotation & "*/" &NL; 
									
						// Write the method function 
			js = js & "#cfcFunctions[i].name#: function(#parmList#){}";

						// Add a comma to the end of the function if it isnt the last function
			if (i neq arrayLen(cfcFunctions)) js = js & ",";
			
			js = js & NL;
						
		} // End loop cfcFunctions	
		
		return js;
	</cfscript>
</cffunction>

<cffunction name="getPropertiesSection" hint="" access="private" returntype="string" output="true">
	<cfargument name="cfcProps" hint="The metadata properties array" type="array" required="Yes">
	<cfscript>
		var local = {};
		var cfcProperties = arguments.cfcProps;
		var NL = "#chr(13)&chr(10)#";
		var js = '';

						// NOTE: Support for ORM is limited at present.
						// Could do more here later. eg fieldType, persistant property, etc
												
															
						// Loop over the metaData properties array and create 
						// the markup			
		for (local.i=1; i lte arrayLen(cfcProperties); i=i+1) {
						// Start the JSDuck block for the properties
			js = js & NL & "/**" &NL;
			
						// Get the hint content, if it exists
			local.hint = "";
			if (structKeyExists(cfcProperties[i],'hint')){
				hint = cfcProperties[i].hint;
			}
			
						// Data type
			local.pType = "Any";
			if (structKeyExists(cfcProperties[i],'type')) pType = cfcProperties[i].type;

						// Process the property name
						// Look at whether it is required or not and any default values
			local.propNameStr = cfcProperties[i].name;
			local.propNameAnnotateStr = propNameStr & " Required.";
			
			if (structKeyExists(cfcProperties[i],'required')) {
				if (not cfcProperties[i].required) {
								// Not required. Therefore there should be a 'default' attribute
					local.defValue = 'Any';
					if (structKeyExists(cfcProperties[i],'default')) {
						if (cfcProperties[i]['default'] neq '') {
							defValue = cfcProperties[i]['default'];
						} else {
							defValue = "''";
						}
						
					}
					propNameAnnotateStr = '[#cfcProperties[i].name#=#defValue#]';
				}
			}

			// eg @property {Type} [name="default value"]
			js = js & "@property {#pType#} #propNameAnnotateStr# #hint#" & NL & "*/" & NL;
			
						
		} // End loop cfcProperties			
		return js;
	</cfscript>
</cffunction>

<cffunction name="getPackageAndName" hint="Removes the extraneous path information and returns just the relevant package and name" access="private" returntype="string" output="true">
	<cfargument name="packageName" hint="The package name" type="string" required="Yes">
	<cfargument name="metaFullName" hint="The fullname from the component metadata" type="string" required="Yes">
	<cfscript>
		var local = {};
						// Could also pass the DisplayName and use that here instead of the cfc filename.
						// Set the last list item delimited by '.' to the DisplayName.
						// NOTE that you might run into issues if you are using extend and the extend is 
						// different to the displayName.
		local.PackAndName = arguments.metaFullName;
		local.packagePos = findNoCase(arguments.packageName,arguments.metaFullName);
		if (packagePos) {
			PackAndName = mid(arguments.metaFullName,packagePos,len(arguments.metaFullName));
		}
		return PackAndName;
	</cfscript>
</cffunction>

<!--- 
<cffunction name="writeOverviewSummaryAndFrame" hint="writes the overview-summary.html" access="private" returntype="void" output="false">
	<cfargument name="qMetadata" hint="the meta data query" type="query" required="Yes">
	<cfscript>
		var qPackages = 0;
	</cfscript>
		<cfquery name="qPackages" dbtype="query" debug="false">
			SELECT DISTINCT
				package
			FROM
				arguments.qMetaData
			ORDER BY
				package
		</cfquery>

	<cfscript>
		writeTemplate(path=getOutputDir() & "/overview-summary.html",
					template="#instance.static.TEMPLATE_PATH#/overview-summary.html",
					projectTitle = getProjectTitle(),
					qPackages = qPackages);


		//overview frame
		writeTemplate(path=getOutputDir() & "/overview-frame.html",
					template="#instance.static.TEMPLATE_PATH#/overview-frame.html",
					projectTitle=getProjectTitle(),
					qPackages = qPackages);
	</cfscript>
</cffunction>

<cffunction name="writeAllClassesFrame" hint="writes the allclasses-frame.html" access="private" returntype="void" output="false">
	<cfargument name="qMetadata" hint="the meta data query" type="query" required="Yes">
	<cfscript>
		arguments.qMetadata = getMetaSubquery(query=arguments.qMetaData, orderby="name asc");

		writeTemplate(path=getOutputDir() & "/allclasses-frame.html",
					template="#instance.static.TEMPLATE_PATH#/allclasses-frame.html",
					qMetaData = arguments.qMetaData);
	</cfscript>
</cffunction>
 --->
<cffunction name="getOutputDir" access="private" returntype="string" output="false">
	<cfreturn instance.outputDir />
</cffunction>

<cffunction name="setOutputDir" access="private" returntype="void" output="false">
	<cfargument name="outputDir" type="string" required="true">
	<cfset instance.outputDir = arguments.outputDir />
</cffunction>

<cffunction name="getProjectTitle" access="private" returntype="string" output="false">
	<cfreturn instance.projectTitle />
</cffunction>

<cffunction name="setProjectTitle" access="private" returntype="void" output="false">
	<cfargument name="projectTitle" type="string" required="true">
	<cfset instance.projectTitle = arguments.projectTitle />
</cffunction>

</cfcomponent>